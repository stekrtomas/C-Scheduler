#include "gthr.h"

int retPriority(struct priority_t prior)
{
    return prior.priority + prior.tmpPriority;
}

int currentTime(void) {
    struct timespec ts;
    timespec_get(&ts, TIME_UTC);
    return (int) ts.tv_sec * 1000000L + ts.tv_nsec / 1000; //time in us
}

// function triggered periodically by timer (SIGALRM)
void gthandle(int sig) {
    gtyield();
}

// initialize first thread as current context
void gtinit(scheduler_t scheduler) {
    gtcur = &gttbl[0];            // initialize current thread with thread #0
    gtcur->st = Running;        // set current to running
    signal(SIGALRM, gthandle);    // register SIGALRM, signal from timer generated by alarm
    gtcur->prior.tickets = 1;
    totalTickets = 1;
    schedulerType = scheduler;

    gtcur->stats.lastStart = currentTime();
    gtcur->stats.minRunTime = 999999;
    gtcur->stats.minWaitTime = 999999;

    /* initialize random seed: */
    srand (time(NULL));
}

// exit thread
void __attribute__((noreturn)) gtret(int ret) {
    if (gtcur != &gttbl[0]) {    // if not an initial thread,
        gtcur->st = Unused;        // set current thread as unused
        gtyield();                    // yield and make possible to switch to another thread
        assert(!"reachable");        // this code should never be reachable ... (if yes, returning function on stack was corrupted)
    }
    while (gtyield());            // if initial thread, wait for other to terminate
    exit(ret);
}

// switch from one thread to other
bool gtyield(void) {
    struct gt *p;
    struct gtctx *old, *new;
    int runTime = 0;
    int waitTime = 0;
    int i;
    resetsig(SIGALRM);            // reset signal
    p = gtcur;


    if(schedulerType == LotteryScheduler){ // lottery scheduler
        int ticket = rand() % totalTickets + 1; // generate ticket
        int ticketSeen = 0;
        for (i = 0; i < MaxGThreads; i++)
        {
            if (gttbl[i].prior.tickets + ticketSeen > ticket) {
                p = &gttbl[i];
                break;
            }
            ticketSeen += gttbl[i].prior.tickets;
        }

    }
    else { //Priority scheduler
        int maxPriority = -1;
        for (i = 0; i < MaxGThreads; i++) // find max priority
        {
            if (gttbl[i].st != Unused && retPriority(gttbl[i].prior) > maxPriority) {
                maxPriority = retPriority(gttbl[i].prior);
            }
        }

        struct gt *start;
        while (p->st != Ready || retPriority(p->prior) <
                                 maxPriority) {            // iterate through gttbl[] until we find new thread in state Ready
            if (++p == &gttbl[MaxGThreads]) {  // at the end rotate to the beginning
                p = &gttbl[0];
                start = p; //start on current thread
                do //find all threads, not run
                {
                    if (++p == &gttbl[MaxGThreads]) {
                        p = &gttbl[0];
                    }
                    if (p->st != Running)// add tmp priority to threads that not run
                    {
                        p->prior.tmpPriority++;
                    }
                } while (p != start);
            }
            if (p == gtcur)                        // did not find any other Ready threads
                return false;
        }
    }

    if (gtcur->stats.lastStart != 0) {//first start
        runTime = currentTime() - gtcur->stats.lastStart;
        gtcur->stats.runTime += runTime;
        gtcur->stats.lastSleep = currentTime();
        //min and max time
        if (runTime > gtcur->stats.maxRunTime) {
            gtcur->stats.maxRunTime = runTime;
        }
        if (runTime < gtcur->stats.minRunTime || gtcur->stats.minRunTime == 0) {
            gtcur->stats.minRunTime = runTime;
        }
    }

    if (gtcur->st != Unused)            // switch current to Ready and new thread found in previous loop to Running
        gtcur->st = Ready;
    p->st = Running;
    p->prior.tmpPriority = 0;
    old = &gtcur->ctx;                    // prepare pointers to context of current (will become old)
    new = &p->ctx;                        // and new to new thread found in previous loop
    gtcur = p;                            // switch current indicator to new thread
    gtswtch(old, new);                    // perform context switch (assembly in gtswtch.S)




    waitTime = currentTime() - gtcur->stats.lastSleep;
    gtcur->stats.waitTime += waitTime;
    gtcur->stats.lastStart = currentTime();
    //min and max time
    if (waitTime > gtcur->stats.maxWaitTime) {
        gtcur->stats.maxWaitTime = waitTime;
    }
    if (waitTime < gtcur->stats.minWaitTime || gtcur->stats.minWaitTime == 0) {
        gtcur->stats.minWaitTime = waitTime;
    }
    gtcur->stats.waitCount++;

    return true;
}

// return function for terminating thread
void gtstop(void) {
    gtret(0);
}

// create new thread by providing pointer to function that will act like "run" method
int gtgo(void( *f)(void),int priority) {
    char *stack;
    struct gt *p;

    for (p = &gttbl[0];; p++)            // find an empty slot
        if (p ==
            &gttbl[MaxGThreads])        // if we have reached the end, gttbl is full and we cannot create a new thread
            return -1;
        else if (p->st == Unused)
            break;                                // new slot was found

    stack = malloc(StackSize);            // allocate memory for stack of newly created thread
    if (!stack)
        return -1;

    *(uint64_t * ) & stack[StackSize -
                           8] = (uint64_t) gtstop;    //	put into the stack returning function gtstop in case function calls return
    *(uint64_t * ) & stack[StackSize - 16] = (uint64_t) f;        //  put provided function as a main "run" function
    p->ctx.rsp = (uint64_t) & stack[StackSize - 16];            //  set stack pointer
    p->st = Ready;                                                //  set state

    p->stats.lastSleep = currentTime();
    p->prior.priority = priority;
    p->prior.tmpPriority = 0;

    //if lottery scheduler is enable tickets = priority + 1;
    int ticket = priority + 1;
    p->prior.tickets = ticket;
    totalTickets += ticket;

    return 0;
}

void resetsig(int sig) {
    if (sig == SIGALRM) {
        alarm(0);            // Clear pending alarms if any
    }

    sigset_t set;                // Create signal set
    sigemptyset(&set);        // Clear it
    sigaddset(&set, sig);    // Set signal (we use SIGALRM)

    sigprocmask(SIG_UNBLOCK, &set, NULL);    // Fetch and change the signal mask

    if (sig == SIGALRM) {
        // Generate alarms
        ualarm(500, 500);        // Schedule signal after given number of microseconds
    }
}

int uninterruptibleNanoSleep(time_t sec, long nanosec) {
    struct timespec req;
    req.tv_sec = sec;
    req.tv_nsec = nanosec;

    do {
        if (0 != nanosleep(&req, &req)) {
            if (errno != EINTR)
                return -1;
        } else {
            break;
        }
    } while (req.tv_sec > 0 || req.tv_nsec > 0);
    return 0; /* Return success */
}
